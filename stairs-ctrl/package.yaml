substitutions:
  device_name: stairs-ctrl
  device_friendly_name: stairs-ctrl-strip
  device_comment: "Stairs controller"
  device_version: "0.1-rc1"

  system_reboot_timeout: 60min
  system_log_level: INFO
  system_api_key: "00000000000000000000000000000000"
  system_ota_password: "changeme"
  system_timezone: UTC

  sntp_server: time1.google.com
  web_include_internal: "false"
  web_local: "false"

  light_num_leds: "244"
  light_transition_length: 1.5s
  light_brightness_r: "1"
  light_brightness_g: "1"
  light_brightness_b: "1"
  light_led_map: '{{0,1,2,3,4,5},{10,9,8,7,6},{11,12,13,14},{20,19,18,17,16,15}}'

  ethernet_mdc_pin: GPIO23
  ethernet_mdio_pin: GPIO18
  ethernet_clk_pin: GPIO17
  ethernet_phy_addr: "0"
  ethernet_power_pin: GPIO5

  temperature_sensor_dig: "0x6f0623b004a68a28"
  temperature_sensor_ssr: "0xca00000054519528"
  uptime_update_interval: 1min

esphome:
  name: ${device_name}
  friendly_name: ${device_friendly_name}
  comment: ${device_comment}
  project: 
    name: timota.${device_name}
    version: ${device_version}

  includes:
    - includes/led_helpers_fcob.h

  devices:
    - id: light_strip
      name: ${device_friendly_name}
  
esp32:
  board: esp32dev
  framework:
    type: esp-idf

ethernet:
  type: LAN8720
  mdc_pin: ${ethernet_mdc_pin}
  mdio_pin: ${ethernet_mdio_pin}
  clk:
    pin: ${ethernet_clk_pin}
    mode: CLK_OUT
  phy_addr: ${ethernet_phy_addr}
  power_pin: ${ethernet_power_pin}

api:
  id: api_server
  reboot_timeout: ${system_reboot_timeout}
  encryption:
    key: ${system_api_key}

ota:
  - platform: esphome
    password: ${system_ota_password}

logger:
  level: ${system_log_level}

time:
  - platform: sntp
    id: sntp_time
    timezone: ${system_timezone}
    servers:
    - ${sntp_server}

web_server:
  include_internal: ${web_include_internal}
  local: ${web_local}
  version: 3

globals:
  - id: map
    type: std::vector<std::vector<int>>
    restore_value: no
    initial_value: ${light_led_map}

button:
  - platform: restart
    name: Restart
    entity_category: diagnostic

  - platform: safe_mode
    internal: false
    name: Safe mode
    entity_category: diagnostic
    disabled_by_default: True

one_wire:
  - platform: gpio
    pin: GPIO13

sensor:
  - platform: dallas_temp
    address: ${temperature_sensor_dig}
    id: dig_temperature
    name: "Temperature Dig Quad"
    unit_of_measurement: "°C"
    device_class: temperature
    update_interval: ${uptime_update_interval}
    device_id: light_strip

  - platform: dallas_temp
    address: ${temperature_sensor_ssr}
    id: ssr_temperature
    name: "Temperature SSR"
    unit_of_measurement: "°C"
    device_class: temperature
    update_interval: 60s
    device_id: light_strip

switch:

  - platform: gpio
    name: "Digital LED Power Relay"
    id: dig_power
    pin: GPIO15
    device_id: light_strip
    entity_category: config
    disabled_by_default: True

  - platform: factory_reset
    name: Restart with Factory Default Settings

  - platform: template
    name: "Snake (zig-zag rows)"
    id: snake_mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    device_id: light_strip
    entity_category: config

  - platform: template
    name: "Subtle Wobble"
    id: subtle_wobble_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: mdi:sine-wave
    device_id: light_strip
    entity_category: config

text_sensor:
  - platform: uptime
    update_interval: 1min
    name: Uptime
    format:
      separator: " "
    entity_category: diagnostic

number:
  - platform: template
    name: "Per-LED Time (ms)"
    id: per_led_ms
    min_value: 1
    max_value: 200
    step: 1
    initial_value: 18
    optimistic: true
    entity_category: config
    device_id: light_strip

  - platform: template
    name: "Fade Steps"
    id: fade_steps_num
    min_value: 1
    max_value: 64
    step: 1
    initial_value: 1
    optimistic: true
    entity_category: config
    device_id: light_strip

  - platform: template
    name: "Row Trigger Threshold"
    id: row_trigger_threshold
    min_value: 0.10
    max_value: 1.00
    step: 0.01
    initial_value: 0.55
    optimistic: true
    entity_category: config
    device_id: light_strip

  - platform: template
    name: "Wobble Strength (hue °)"
    id: subtle_hue_amp
    min_value: 0.0
    max_value: 15.0
    step: 0.5
    initial_value: 3.0
    optimistic: true
    entity_category: config
    device_id: light_strip

  - platform: template
    name: "Wobble Frequency (deg/s)"
    id: wobble_freq_deg
    min_value: 0.0
    max_value: 24.0
    step: 0.5
    initial_value: 12.0
    optimistic: true
    restore_value: true
    entity_category: config
    device_id: light_strip

# -------------------------
# SELECTS
# -------------------------
select:
  - platform: template
    name: "Easing"
    id: easing_mode
    optimistic: true
    options:
      - Linear
      - Cubic InOut
      - Quint InOut
    initial_option: Cubic InOut
    entity_category: config
    device_id: light_strip

light:

  - platform: esp32_rmt_led_strip
    id: light_dig
    name: Wall
    rgb_order: RGB
    color_correct:
      - ${light_brightness_r}
      - ${light_brightness_g}
      - ${light_brightness_b}
    pin: GPIO16
    num_leds: ${light_num_leds}
    chipset: WS2811
    max_refresh_rate: 16ms
    use_psram: False
    restore_mode: ALWAYS_OFF
    device_id: light_strip
    default_transition_length: ${light_transition_length}
    on_turn_on: 
      then:
        - switch.turn_on: dig_power
    on_turn_off:
      then:
        - switch.turn_off: dig_power
    effects:
      - addressable_lambda:
          name: "FCOB Fill Up"
          update_interval: 16ms
          lambda: |-
            using namespace ledhelpers;
            auto &tracker = global_tracker();
            tracker.bind_map(&id(map));
            if (id(map).empty()) {
              for (int i = 0; i < it.size(); ++i) it[i] = esphome::Color::BLACK;
              return;
            }

            // Pull current UI settings into a runtime config.
            RuntimeConfig cfg;
            cfg.per_led_ms = (uint32_t) id(per_led_ms).state;
            if (cfg.per_led_ms < 1u) cfg.per_led_ms = 1u;
            cfg.fade_steps = (int) id(fade_steps_num).state;
            if (cfg.fade_steps < 1) cfg.fade_steps = 1;
            cfg.row_threshold = clamp01(id(row_trigger_threshold).state);
            cfg.snake = id(snake_mode).state;
            const auto ease_opt = id(easing_mode).state;
            if (ease_opt == "Linear") cfg.ease = EaseProfile::Linear;
            else if (ease_opt == "Quint InOut") cfg.ease = EaseProfile::QuintInOut;
            else cfg.ease = EaseProfile::CubicInOut;
            cfg.wobble_enabled = id(subtle_wobble_enable).state;
            cfg.wobble_amp_deg = id(subtle_hue_amp).state;
            if (cfg.wobble_amp_deg < 0.0f) cfg.wobble_amp_deg = 0.0f;
            cfg.wobble_freq_deg = id(wobble_freq_deg).state;
            if (cfg.wobble_freq_deg < 0.0f) cfg.wobble_freq_deg = 0.0f;

            // Warm-start logic so scan-in/out resumes from the previous effect.
            EffectPlan desired{FlowMode::Fill, RowOrder::BottomToTop};
            struct LocalState {
              bool initialized{false};
              bool snake{false};
            };
            static LocalState state;
            if (initial_run) state.initialized = false;

            bool restart = false;
            const auto active_plan = tracker.plan();
            if (!state.initialized || state.snake != cfg.snake) restart = true;
            if (active_plan.flow != desired.flow || active_plan.order != desired.order) restart = true;
            if (restart) {
              tracker.sync_from_strip(it, cfg.snake);
              tracker.start_effect(desired, true);
              state.snake = cfg.snake;
              state.initialized = true;
            }

            // Paint the frame (wobble keeps running even when finished).
            tracker.render_frame(it, cfg, current_color, millis());

      - addressable_lambda:
          name: "FCOB Fill Down"
          update_interval: 16ms
          lambda: |-
            using namespace ledhelpers;
            auto &tracker = global_tracker();
            tracker.bind_map(&id(map));
            if (id(map).empty()) {
              for (int i = 0; i < it.size(); ++i) it[i] = esphome::Color::BLACK;
              return;
            }

            // Mirror Fill Up but with the opposite row order.
            RuntimeConfig cfg;
            cfg.per_led_ms = (uint32_t) id(per_led_ms).state;
            if (cfg.per_led_ms < 1u) cfg.per_led_ms = 1u;
            cfg.fade_steps = (int) id(fade_steps_num).state;
            if (cfg.fade_steps < 1) cfg.fade_steps = 1;
            cfg.row_threshold = clamp01(id(row_trigger_threshold).state);
            cfg.snake = id(snake_mode).state;
            const auto ease_opt = id(easing_mode).state;
            if (ease_opt == "Linear") cfg.ease = EaseProfile::Linear;
            else if (ease_opt == "Quint InOut") cfg.ease = EaseProfile::QuintInOut;
            else cfg.ease = EaseProfile::CubicInOut;
            cfg.wobble_enabled = id(subtle_wobble_enable).state;
            cfg.wobble_amp_deg = id(subtle_hue_amp).state;
            if (cfg.wobble_amp_deg < 0.0f) cfg.wobble_amp_deg = 0.0f;
            cfg.wobble_freq_deg = id(wobble_freq_deg).state;
            if (cfg.wobble_freq_deg < 0.0f) cfg.wobble_freq_deg = 0.0f;

            EffectPlan desired{FlowMode::Fill, RowOrder::TopToBottom};
            struct LocalState {
              bool initialized{false};
              bool snake{false};
            };
            static LocalState state;
            if (initial_run) state.initialized = false;

            bool restart = false;
            const auto active_plan = tracker.plan();
            if (!state.initialized || state.snake != cfg.snake) restart = true;
            if (active_plan.flow != desired.flow || active_plan.order != desired.order) restart = true;
            if (restart) {
              tracker.sync_from_strip(it, cfg.snake);
              tracker.start_effect(desired, true);
              state.snake = cfg.snake;
              state.initialized = true;
            }

            // Repaint rows with the helper’s current progress.
            tracker.render_frame(it, cfg, current_color, millis());

      - addressable_lambda:
          name: "FCOB Off Up"
          update_interval: 16ms
          lambda: |-
            using namespace ledhelpers;
            auto &tracker = global_tracker();
            tracker.bind_map(&id(map));
            if (id(map).empty()) {
              for (int i = 0; i < it.size(); ++i) it[i] = esphome::Color::BLACK;
              return;
            }

            // OFF animation shares the same runtime config inputs.
            RuntimeConfig cfg;
            cfg.per_led_ms = (uint32_t) id(per_led_ms).state;
            if (cfg.per_led_ms < 1u) cfg.per_led_ms = 1u;
            cfg.fade_steps = (int) id(fade_steps_num).state;
            if (cfg.fade_steps < 1) cfg.fade_steps = 1;
            cfg.row_threshold = clamp01(id(row_trigger_threshold).state);
            cfg.snake = id(snake_mode).state;
            const auto ease_opt = id(easing_mode).state;
            if (ease_opt == "Linear") cfg.ease = EaseProfile::Linear;
            else if (ease_opt == "Quint InOut") cfg.ease = EaseProfile::QuintInOut;
            else cfg.ease = EaseProfile::CubicInOut;
            cfg.wobble_enabled = id(subtle_wobble_enable).state;
            cfg.wobble_amp_deg = id(subtle_hue_amp).state;
            if (cfg.wobble_amp_deg < 0.0f) cfg.wobble_amp_deg = 0.0f;
            cfg.wobble_freq_deg = id(wobble_freq_deg).state;
            if (cfg.wobble_freq_deg < 0.0f) cfg.wobble_freq_deg = 0.0f;

            EffectPlan desired{FlowMode::Off, RowOrder::BottomToTop};
            struct LocalState {
              bool initialized{false};
              bool snake{false};
              bool shutdown_scheduled{false};
              uint32_t shutdown_at{0};
            };
            static LocalState state;
            if (initial_run) state.initialized = false;

            bool restart = false;
            const auto active_plan = tracker.plan();
            if (!state.initialized || state.snake != cfg.snake) restart = true;
            if (active_plan.flow != desired.flow || active_plan.order != desired.order) restart = true;
            if (restart) {
              tracker.sync_from_strip(it, cfg.snake);
              tracker.start_effect(desired, true);
              state.snake = cfg.snake;
              state.initialized = true;
              state.shutdown_scheduled = false;
            }

            // Continue ramping down rows from the stored progress.
            tracker.render_frame(it, cfg, current_color, millis());

            if (!tracker.finished()) {
              state.shutdown_scheduled = false;
              return;
            }

            if (!state.shutdown_scheduled) {
              state.shutdown_scheduled = true;
              state.shutdown_at = millis() + 50u;
              return;
            }

            if ((int32_t)(millis() - state.shutdown_at) >= 0) {
              auto call = id(light_dig).turn_off();
              call.perform();
              state.shutdown_scheduled = false;
            }

      - addressable_lambda:
          name: "FCOB Off Down"
          update_interval: 16ms
          lambda: |-
            using namespace ledhelpers;
            auto &tracker = global_tracker();
            tracker.bind_map(&id(map));
            if (id(map).empty()) {
              for (int i = 0; i < it.size(); ++i) it[i] = esphome::Color::BLACK;
              return;
            }

            // Same as Off Up but running from the top row.
            RuntimeConfig cfg;
            cfg.per_led_ms = (uint32_t) id(per_led_ms).state;
            if (cfg.per_led_ms < 1u) cfg.per_led_ms = 1u;
            cfg.fade_steps = (int) id(fade_steps_num).state;
            if (cfg.fade_steps < 1) cfg.fade_steps = 1;
            cfg.row_threshold = clamp01(id(row_trigger_threshold).state);
            cfg.snake = id(snake_mode).state;
            const auto ease_opt = id(easing_mode).state;
            if (ease_opt == "Linear") cfg.ease = EaseProfile::Linear;
            else if (ease_opt == "Quint InOut") cfg.ease = EaseProfile::QuintInOut;
            else cfg.ease = EaseProfile::CubicInOut;
            cfg.wobble_enabled = id(subtle_wobble_enable).state;
            cfg.wobble_amp_deg = id(subtle_hue_amp).state;
            if (cfg.wobble_amp_deg < 0.0f) cfg.wobble_amp_deg = 0.0f;
            cfg.wobble_freq_deg = id(wobble_freq_deg).state;
            if (cfg.wobble_freq_deg < 0.0f) cfg.wobble_freq_deg = 0.0f;

            EffectPlan desired{FlowMode::Off, RowOrder::TopToBottom};
            struct LocalState {
              bool initialized{false};
              bool snake{false};
              bool shutdown_scheduled{false};
              uint32_t shutdown_at{0};
            };
            static LocalState state;
            if (initial_run) state.initialized = false;

            bool restart = false;
            const auto active_plan = tracker.plan();
            if (!state.initialized || state.snake != cfg.snake) restart = true;
            if (active_plan.flow != desired.flow || active_plan.order != desired.order) restart = true;
            if (restart) {
              tracker.sync_from_strip(it, cfg.snake);
              tracker.start_effect(desired, true);
              state.snake = cfg.snake;
              state.initialized = true;
              state.shutdown_scheduled = false;
            }

            // Let the helper handle tail fade + wobble repaint.
            tracker.render_frame(it, cfg, current_color, millis());

            if (!tracker.finished()) {
              state.shutdown_scheduled = false;
              return;
            }

            if (!state.shutdown_scheduled) {
              state.shutdown_scheduled = true;
              state.shutdown_at = millis() + 50u;
              return;
            }

            if ((int32_t)(millis() - state.shutdown_at) >= 0) {
              auto call = id(light_dig).turn_off();
              call.perform();
              state.shutdown_scheduled = false;
            }
