substitutions:
  device: 
    name:                   stairs-ctrl-real
    comment:                "Stair controller real"
    version:                "0.1-rc1"
  system:
    reboot_timeout:         60min
    log_level:              DEBUG
  sntp:
    server:                 192.168.3.1
  web_server:
    include_internal:       'true'
    local:                  'false'
  light:
    digital:
      num_leds:             "244"
      transition_length:    1.5s
  num_leds: "244"

esphome:
  name: ${device.name}
  friendly_name: ${device.name}
  comment: ${device.comment}
  project: 
    name: timota.${device.name}
    version: ${device.version}

  includes:
    - includes/led_helpers_fcob.h

  devices:
    - id: light_digital
      name: ${device.name}-dig
  
esp32:
  board: esp32dev
  framework:
    type: esp-idf

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: ${system.reboot_timeout}
  # used to prevent flicking during effects
  power_save_mode: none

  ap:
    ssid: ${device.name}
    password: !secret failover_password

api:
  id: api_server
  reboot_timeout: ${system.reboot_timeout}
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

logger:
  level: ${system.log_level}

time:
  - platform: sntp
    id: sntp_time
    timezone: !secret sys_time_zone
    servers:
    - ${sntp.server}

web_server:
  include_internal: ${web_server.include_internal}
  local: ${web_server.local}
  version: 3

button:
  - platform: restart
    name: Restart
    entity_category: diagnostic

  - platform: safe_mode
    internal: false
    name: Safe mode
    entity_category: config
    disabled_by_default: True

globals:
  - id: map
    type: std::vector<std::vector<int>>
    restore_value: no
    initial_value: '{{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28},{59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29},{60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97},{136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101,100,99,98},{137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175},{209,208,207,206,205,204,203,202,201,200,199,198,197,196,195,194,193,192,191,190,189,188,187,186,185,184,183,182,181,180,179,178,177,176},{210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243}}'

switch:

  - platform: gpio
    name: "Digital LED Power Relay"
    id: dig_power
    pin: GPIO15
    device_id: light_digital
    entity_category: config
    disabled_by_default: True

  - platform: factory_reset
    name: Restart with Factory Default Settings

  - platform: template
    name: "Snake (zig-zag rows)"
    id: snake_mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    name: "Subtle Wobble"
    id: subtle_wobble_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: mdi:sine-wave


text_sensor:
  - platform: uptime
    update_interval: 1min
    name: Uptime
    format:
      separator: " "
    entity_category: diagnostic

number:
  - platform: template
    name: "Per-LED Time (ms)"
    id: per_led_ms
    min_value: 1
    max_value: 200
    step: 1
    initial_value: 24
    optimistic: true

  - platform: template
    name: "Fade Steps"
    id: fade_steps_num
    min_value: 1
    max_value: 64
    step: 1
    initial_value: 5
    optimistic: true

  - platform: template
    name: "Row Trigger Threshold"
    id: row_trigger_threshold
    min_value: 0.10
    max_value: 1.00
    step: 0.01
    initial_value: 0.20
    optimistic: true

  - platform: template
    name: "Wobble Strength (hue °)"
    id: subtle_hue_amp
    min_value: 0.0
    max_value: 15.0
    step: 0.5
    initial_value: 3.0
    optimistic: true

  - platform: template
    name: "Wobble Frequency (deg/s)"
    id: wobble_freq_deg
    min_value: 0.0
    max_value: 24.0
    step: 0.5
    initial_value: 12.0
    optimistic: true
    restore_value: true

# -------------------------
# SELECTS
# -------------------------
select:
  - platform: template
    name: "Easing"
    id: easing_mode
    optimistic: true
    options:
      - Linear
      - Cubic InOut
      - Quint InOut
    initial_option: Cubic InOut

light:

  - platform: esp32_rmt_led_strip
    id: light_dig
    name: Wall
    rgb_order: RGB
    pin: GPIO16
    num_leds: '$num_leds'
    chipset: WS2811
    max_refresh_rate: 16ms
    use_psram: False
    restore_mode: ALWAYS_OFF
    device_id: light_digital
    default_transition_length: ${light.digital.transition_length}
    on_turn_on: 
      then:
        - switch.turn_on: dig_power
    on_turn_off:
      then:
        - switch.turn_off: dig_power
    effects:
      - addressable_lambda:
          name: "FCOB Fill Up"
          update_interval: 16ms
          lambda: |-
            using namespace ledhelpers;
            auto &tracker = global_tracker();
            tracker.bind_map(&id(map));
            if (id(map).empty()) {
              for (int i = 0; i < it.size(); ++i) it[i] = esphome::Color::BLACK;
              return;
            }

            // Pull current UI settings into a runtime config.
            RuntimeConfig cfg;
            cfg.per_led_ms = (uint32_t) id(per_led_ms).state;
            if (cfg.per_led_ms < 1u) cfg.per_led_ms = 1u;
            cfg.fade_steps = (int) id(fade_steps_num).state;
            if (cfg.fade_steps < 1) cfg.fade_steps = 1;
            cfg.row_threshold = clamp01(id(row_trigger_threshold).state);
            cfg.snake = id(snake_mode).state;
            const auto ease_opt = id(easing_mode).state;
            if (ease_opt == "Linear") cfg.ease = EaseProfile::Linear;
            else if (ease_opt == "Quint InOut") cfg.ease = EaseProfile::QuintInOut;
            else cfg.ease = EaseProfile::CubicInOut;
            cfg.wobble_enabled = id(subtle_wobble_enable).state;
            cfg.wobble_amp_deg = id(subtle_hue_amp).state;
            if (cfg.wobble_amp_deg < 0.0f) cfg.wobble_amp_deg = 0.0f;
            cfg.wobble_freq_deg = id(wobble_freq_deg).state;
            if (cfg.wobble_freq_deg < 0.0f) cfg.wobble_freq_deg = 0.0f;

            // Warm-start logic so scan-in/out resumes from the previous effect.
            EffectPlan desired{FlowMode::Fill, RowOrder::BottomToTop};
            struct LocalState {
              bool initialized{false};
              bool snake{false};
            };
            static LocalState state;
            if (initial_run) state.initialized = false;

            bool restart = false;
            const auto active_plan = tracker.plan();
            if (!state.initialized || state.snake != cfg.snake) restart = true;
            if (active_plan.flow != desired.flow || active_plan.order != desired.order) restart = true;
            if (restart) {
              tracker.sync_from_strip(it, cfg.snake);
              tracker.start_effect(desired, true);
              state.snake = cfg.snake;
              state.initialized = true;
            }

            // Paint the frame (wobble keeps running even when finished).
            tracker.render_frame(it, cfg, current_color, millis());

      - addressable_lambda:
          name: "FCOB Fill Down"
          update_interval: 16ms
          lambda: |-
            using namespace ledhelpers;
            auto &tracker = global_tracker();
            tracker.bind_map(&id(map));
            if (id(map).empty()) {
              for (int i = 0; i < it.size(); ++i) it[i] = esphome::Color::BLACK;
              return;
            }

            // Mirror Fill Up but with the opposite row order.
            RuntimeConfig cfg;
            cfg.per_led_ms = (uint32_t) id(per_led_ms).state;
            if (cfg.per_led_ms < 1u) cfg.per_led_ms = 1u;
            cfg.fade_steps = (int) id(fade_steps_num).state;
            if (cfg.fade_steps < 1) cfg.fade_steps = 1;
            cfg.row_threshold = clamp01(id(row_trigger_threshold).state);
            cfg.snake = id(snake_mode).state;
            const auto ease_opt = id(easing_mode).state;
            if (ease_opt == "Linear") cfg.ease = EaseProfile::Linear;
            else if (ease_opt == "Quint InOut") cfg.ease = EaseProfile::QuintInOut;
            else cfg.ease = EaseProfile::CubicInOut;
            cfg.wobble_enabled = id(subtle_wobble_enable).state;
            cfg.wobble_amp_deg = id(subtle_hue_amp).state;
            if (cfg.wobble_amp_deg < 0.0f) cfg.wobble_amp_deg = 0.0f;
            cfg.wobble_freq_deg = id(wobble_freq_deg).state;
            if (cfg.wobble_freq_deg < 0.0f) cfg.wobble_freq_deg = 0.0f;

            EffectPlan desired{FlowMode::Fill, RowOrder::TopToBottom};
            struct LocalState {
              bool initialized{false};
              bool snake{false};
            };
            static LocalState state;
            if (initial_run) state.initialized = false;

            bool restart = false;
            const auto active_plan = tracker.plan();
            if (!state.initialized || state.snake != cfg.snake) restart = true;
            if (active_plan.flow != desired.flow || active_plan.order != desired.order) restart = true;
            if (restart) {
              tracker.sync_from_strip(it, cfg.snake);
              tracker.start_effect(desired, true);
              state.snake = cfg.snake;
              state.initialized = true;
            }

            // Repaint rows with the helper’s current progress.
            tracker.render_frame(it, cfg, current_color, millis());

      - addressable_lambda:
          name: "FCOB Off Up"
          update_interval: 16ms
          lambda: |-
            using namespace ledhelpers;
            auto &tracker = global_tracker();
            tracker.bind_map(&id(map));
            if (id(map).empty()) {
              for (int i = 0; i < it.size(); ++i) it[i] = esphome::Color::BLACK;
              return;
            }

            // OFF animation shares the same runtime config inputs.
            RuntimeConfig cfg;
            cfg.per_led_ms = (uint32_t) id(per_led_ms).state;
            if (cfg.per_led_ms < 1u) cfg.per_led_ms = 1u;
            cfg.fade_steps = (int) id(fade_steps_num).state;
            if (cfg.fade_steps < 1) cfg.fade_steps = 1;
            cfg.row_threshold = clamp01(id(row_trigger_threshold).state);
            cfg.snake = id(snake_mode).state;
            const auto ease_opt = id(easing_mode).state;
            if (ease_opt == "Linear") cfg.ease = EaseProfile::Linear;
            else if (ease_opt == "Quint InOut") cfg.ease = EaseProfile::QuintInOut;
            else cfg.ease = EaseProfile::CubicInOut;
            cfg.wobble_enabled = id(subtle_wobble_enable).state;
            cfg.wobble_amp_deg = id(subtle_hue_amp).state;
            if (cfg.wobble_amp_deg < 0.0f) cfg.wobble_amp_deg = 0.0f;
            cfg.wobble_freq_deg = id(wobble_freq_deg).state;
            if (cfg.wobble_freq_deg < 0.0f) cfg.wobble_freq_deg = 0.0f;

            EffectPlan desired{FlowMode::Off, RowOrder::BottomToTop};
            struct LocalState {
              bool initialized{false};
              bool snake{false};
              bool shutdown_scheduled{false};
              uint32_t shutdown_at{0};
            };
            static LocalState state;
            if (initial_run) state.initialized = false;

            bool restart = false;
            const auto active_plan = tracker.plan();
            if (!state.initialized || state.snake != cfg.snake) restart = true;
            if (active_plan.flow != desired.flow || active_plan.order != desired.order) restart = true;
            if (restart) {
              tracker.sync_from_strip(it, cfg.snake);
              tracker.start_effect(desired, true);
              state.snake = cfg.snake;
              state.initialized = true;
              state.shutdown_scheduled = false;
            }

            // Continue ramping down rows from the stored progress.
            tracker.render_frame(it, cfg, current_color, millis());

            if (!tracker.finished()) {
              state.shutdown_scheduled = false;
              return;
            }

            if (!state.shutdown_scheduled) {
              state.shutdown_scheduled = true;
              state.shutdown_at = millis() + 50u;
              return;
            }

            if ((int32_t)(millis() - state.shutdown_at) >= 0) {
              auto call = id(light_dig).turn_off();
              call.perform();
              state.shutdown_scheduled = false;
            }

      - addressable_lambda:
          name: "FCOB Off Down"
          update_interval: 16ms
          lambda: |-
            using namespace ledhelpers;
            auto &tracker = global_tracker();
            tracker.bind_map(&id(map));
            if (id(map).empty()) {
              for (int i = 0; i < it.size(); ++i) it[i] = esphome::Color::BLACK;
              return;
            }

            // Same as Off Up but running from the top row.
            RuntimeConfig cfg;
            cfg.per_led_ms = (uint32_t) id(per_led_ms).state;
            if (cfg.per_led_ms < 1u) cfg.per_led_ms = 1u;
            cfg.fade_steps = (int) id(fade_steps_num).state;
            if (cfg.fade_steps < 1) cfg.fade_steps = 1;
            cfg.row_threshold = clamp01(id(row_trigger_threshold).state);
            cfg.snake = id(snake_mode).state;
            const auto ease_opt = id(easing_mode).state;
            if (ease_opt == "Linear") cfg.ease = EaseProfile::Linear;
            else if (ease_opt == "Quint InOut") cfg.ease = EaseProfile::QuintInOut;
            else cfg.ease = EaseProfile::CubicInOut;
            cfg.wobble_enabled = id(subtle_wobble_enable).state;
            cfg.wobble_amp_deg = id(subtle_hue_amp).state;
            if (cfg.wobble_amp_deg < 0.0f) cfg.wobble_amp_deg = 0.0f;
            cfg.wobble_freq_deg = id(wobble_freq_deg).state;
            if (cfg.wobble_freq_deg < 0.0f) cfg.wobble_freq_deg = 0.0f;

            EffectPlan desired{FlowMode::Off, RowOrder::TopToBottom};
            struct LocalState {
              bool initialized{false};
              bool snake{false};
              bool shutdown_scheduled{false};
              uint32_t shutdown_at{0};
            };
            static LocalState state;
            if (initial_run) state.initialized = false;

            bool restart = false;
            const auto active_plan = tracker.plan();
            if (!state.initialized || state.snake != cfg.snake) restart = true;
            if (active_plan.flow != desired.flow || active_plan.order != desired.order) restart = true;
            if (restart) {
              tracker.sync_from_strip(it, cfg.snake);
              tracker.start_effect(desired, true);
              state.snake = cfg.snake;
              state.initialized = true;
              state.shutdown_scheduled = false;
            }

            // Let the helper handle tail fade + wobble repaint.
            tracker.render_frame(it, cfg, current_color, millis());

            if (!tracker.finished()) {
              state.shutdown_scheduled = false;
              return;
            }

            if (!state.shutdown_scheduled) {
              state.shutdown_scheduled = true;
              state.shutdown_at = millis() + 50u;
              return;
            }

            if ((int32_t)(millis() - state.shutdown_at) >= 0) {
              auto call = id(light_dig).turn_off();
              call.perform();
              state.shutdown_scheduled = false;
            }
